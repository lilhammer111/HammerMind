# 基本操作

查看api文档。

# 缓存写入时间点

写数据库的时候删缓存，读数据库的时候写缓存。

# 缓存雪崩

缓存雪崩是指缓存层支撑不住挂掉了之后，流量会全部往数据库打。

备份处理，同时做好限流熔断降级。

# 缓存穿透

当有恶意用户故意查询大量不存在的数据，由于缓存不会存储这样的查询结果，每次查询都会穿过缓存直接访问数据库。

可以使用空对象缓存或者布隆过滤器解决。

# 缓存击穿

缓存击穿是指某个热点数据（即高频访问数据）在缓存中过期的瞬间，导致大量并发请求直接打到数据库。

如果高频访问期是可预测的，比如秒杀倒计时，那可以将缓存的过期时间设置的比这个过期时间更长。

某些热点数据可以永不过期。

# 热点缓存KEY

比如之前的某个产品很冷门，并没有缓存，但是某个突发事件导致了该产品的请求流量突然很大。

使用redis模拟分布式锁处理，如果该商品对应的键不存在再去查数据库，同时写一份redis缓存。

# 双写不一致

两个线程中，最新的那条数据被先前的数据给覆盖写入了缓存，不是最新的数据成了最新的缓存。

消息队列解决。

# 键值设计

key可以用冒号进行分割，比如，`service-name:table-name:id`，不宜过长。 

value直接使用json字符串存储方便响应。

字符串类型的value不要超过10KB，飞字符串类型不要超过5000个。

非字符串的bigkey，不要用del删除，而要用scan渐进删除。

# 连接池配置

高并发场景下，可以设置maxTotal = maxIdle。 

# 连接池预热

因为redis是懒加载模式，刚开始并不会直接初始化一些空闲连接，所以可以通过模拟请求的方式主动加载一些可用连接。

# 缓存过期策略

以下是Redis主要的缓存过期和删除策略：

1. **定时过期（Timed Expiration）**：
   - 在这种策略中，每个设置了过期时间的键都会有一个定时器。当定时器触发时，键会被立即删除。
   - 这种方法对内存友好，但会消耗大量的CPU资源，尤其是当有大量键同时过期时。
2. **惰性过期（Lazy Expiration）**：
   - 在这种策略中，Redis不会主动删除过期的键。相反，它只在键被访问时检查其是否过期。如果一个键已经过期，当尝试访问它时，它才会被删除。
   - 这种方法节省CPU资源，但如果过期键不被访问，它们会一直占用内存。
3. **定期过期（Periodic Expiration）**：
   - Redis会定期随机测试一些键，并删除其中已经过期的键。
   - 这是一种折中的方法，通过定期操作减少CPU的瞬时峰值，同时也能释放一些未被访问的过期键占用的内存。

# 内存淘汰策略

当Redis的内存使用接近配置的上限时，它还会使用内存淘汰策略来释放空间。Redis提供了多种内存淘汰策略，例如：

1. **volatile-lru**：从已设置过期时间的键中使用LRU（最近最少使用）算法移除。
2. **allkeys-lru**：从所有键中使用LRU算法移除。
3. **volatile-random**：随机移除已设置过期时间的键。
4. **allkeys-random**：随机移除所有键。
5. **volatile-ttl**：移除剩余时间最短的键。
6. **noeviction**：不进行内存淘汰，如果内存达到上限，对于写操作会返回错误。

# redis跳表

跳表（Skip List）是一种概率性数据结构，它基于多层链表，用于存储有序的元素序列。跳表是对标准链表的一种改进，提供了类似于平衡树的查找效率，同时保持了链表插入和删除操作的高效性。

跳表的原理：

1. **多层链表结构**：跳表包含多个层次，每个层次都是一个链表。底层是完整的有序链表，每一层都是上一层的一个“子集”。顶层的链表含有最少的元素（可能只有两个：头和尾）。
2. **节点跨越**：在跳表中，每个节点可能在多个层次上出现。高层的节点“跳过”了下层中的一些节点，这就是“跳表”名字的由来。
3. **搜索操作**：搜索从顶层开始，如果发现下一个节点的值大于或等于要搜索的值，搜索就下降一层继续进行。这个过程一直重复，直到到达底层。
4. **动态平衡**：在插入新节点时，通过随机决定这个节点应该出现在多少层中。通常使用抛硬币的方式来实现这种随机性。
5. **效率**：跳表的平均查找、插入、删除操作的时间复杂度都是O(log n)，其中n是跳表中的元素数量。

跳表的优点：

1. **高效的操作**：跳表提供了平衡树的许多优点，如预测性的O(log n)查找时间，同时保持了链表插入和删除操作的简单性和高效性。
2. **简单的实现**：与红黑树或AVL树等平衡树结构相比，跳表的实现相对简单。
3. **无锁操作**：在并发环境下，跳表可以更容易地进行无锁操作。
4. **动态扩展**：由于跳表的层级是动态生成的，它可以很容易地处理数据的增长。