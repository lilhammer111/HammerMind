# GNU工具

GNU工具是一系列由GNU项目开发的免费软件工具。GNU项目由理查德·斯托曼（Richard Stallman）于1983年发起，旨在创建一个完全自由的类Unix操作系统，即GNU系统。GNU是“GNU's Not Unix”的递归缩写，表明尽管它与Unix兼容，但不包含Unix代码。

GNU工具包括一系列广泛使用的编程工具，如编译器、链接器、调试器等，以及各种常用的命令行工具和应用程序。以下是一些重要的GNU工具：

1. **GCC（GNU Compiler Collection）**：
   - 一个编译器套件，支持C、C++、Objective-C、Fortran、Ada、Go和其他语言。
2. **GNU Make**：
   - 一个构建自动化工具，用于控制生成可执行程序和其他非源代码文件的复杂性。
3. **GDB（GNU Debugger）**：
   - 一个强大的程序调试器，用于追踪和调试程序执行过程中的错误。
4. **Bash（GNU Bourne Again SHell）**：
   - 一个广泛使用的Unix shell，提供了命令行界面和脚本执行能力。
5. **GNU Core Utilities（Coreutils）**：
   - 一套基本的文件、shell和文本操作工具，如`ls`、`cat`、`mv`、`cp`、`echo`、`rm`等。
6. **GNU Binutils**：
   - 一套用于创建和管理二进制程序的工具，包括链接器、汇编器和其他工具。
7. **GNU Emacs**：
   - 一个功能强大、可扩展的文本编辑器，也可用作开发环境。
8. **GIMP（GNU Image Manipulation Program）**：
   - 一个图像编辑和处理程序，类似于Photoshop。

GNU工具的重要特点是它们都遵循GNU通用公共许可证（GPL），这意味着它们是自由软件，用户可以自由地使用、研究、分享和修改这些工具。GNU工具在开源社区中极为流行，并且对现代软件开发产生了深远的影响。

# GCC

GCC（GNU Compiler Collection）是一个由GNU项目开发的编译器套件，它支持多种编程语言。最初，GCC是作为GNU操作系统的官方编译器开发的，现在它已成为大多数现代Unix-like操作系统的标准编译器。GCC的主要组件包括：

1. **前端**：
   - GCC为每种支持的编程语言提供一个前端。前端负责解析源代码（即将代码转换为抽象语法树），并生成中间表示（IR）。主要的前端包括：
     - **gcc**：C语言前端。
     - **g++**：C++语言前端。
     - **gfortran**：Fortran语言前端。
     - 其他语言的前端，如Objective-C、Ada、Go等。
2. **中间表示（IR）**：
   - 中间表示是一种独立于语言和目标机器的代码表示形式。GCC使用一种名为“GIMPLE”的中间表示。
3. **优化器**：
   - 优化器对中间表示进行操作，改进代码的性能和效率。GCC提供了各种优化选项，旨在提高代码的速度、减少内存使用等。
4. **后端**：
   - 后端负责将优化后的中间表示转换为目标机器代码。GCC的后端支持多种不同的处理器架构和操作系统，包括x86、ARM、MIPS等。
   - 后端还包括代码生成器，负责生成机器码或汇编代码。
5. **汇编器（Assembler）和链接器（Linker）**：
   - 虽然这些不是GCC本身的一部分，GCC通常与GNU Binutils一起使用，Binutils提供了汇编器（如`as`）和链接器（如`ld`）。
   - 汇编器将后端生成的汇编代码转换为机器代码，而链接器将多个对象文件链接成最终的可执行文件或库。

GCC是一个功能强大的工具，其复杂性和灵活性允许开发者对编译过程进行精细控制，优化程序性能，以及针对特定硬件进行优化。由于GCC是自由和开源的，它也被广泛用于学术研究和教学中。

# GCC编译过程

GCC（GNU Compiler Collection）的编译过程可以分为几个主要步骤，每个步骤都负责代码转换和优化的不同方面。以下是GCC编译过程的大致流程：

1. **预处理（Preprocessing）**：
   - 在这个阶段，预处理器（如`cpp`）处理源代码文件中的预处理指令。这包括宏定义的扩展、条件编译指令的处理、头文件的包含等。
   - 结果是“纯净”的源代码，已经去除了所有预处理指令。
2. **编译（Compilation）**：
   - 编译器将预处理后的源代码转换成特定平台的汇编代码。
   - 这一步骤包括词法分析、语法分析、语义分析和中间代码生成。然后，它将进行优化，包括删除无用代码、循环优化、寄存器分配等。
3. **汇编（Assembly）**：
   - 汇编器（通常是GNU Assembler，`as`）将编译器生成的汇编代码转换为机器语言（机器代码），并生成目标文件（通常是`.o`文件）。
   - 每个源代码文件通常被编译和汇编成一个单独的目标文件。
4. **链接（Linking）**：
   - 链接器（如GNU Linker，`ld`）将所有的目标文件和必要的库文件链接在一起，形成一个单一的可执行文件。
   - 在这个过程中，链接器解析多个对象文件之间的相互引用，解决符号依赖，还可能进行一些优化和调整。

这个过程可以通过命令行手动执行，也可以通过调用GCC命令一步完成，GCC会自动调用预处理器、编译器、汇编器和链接器。

例如，使用GCC编译C语言程序的命令可能是这样的：

```bash
gcc -o myprogram myprogram.c
```

这个命令将`myprogram.c`文件编译并链接成名为`myprogram`的可执行文件。在这个过程中，GCC会依次执行上述的预处理、编译、汇编和链接步骤。

# GCC常用命令

GCC（GNU Compiler Collection）提供了许多命令行参数，允许用户对编译过程进行详细的控制。以下是一些常用的GCC命令参数：

1. **`-o <file>`**：
   - 指定输出的文件名。例如，`gcc -o program program.c`会创建一个名为`program`的可执行文件。
2. **`-c`**：
   - 只预处理，编译和汇编源代码，但不进行链接。这会生成`.o`文件（目标文件）。
3. **`-g`**：
   - 生成调试信息。如果你想用像GDB这样的调试器调试程序，就需要加上这个选项。
4. **`-Wall`**：
   - 开启大多数警告信息，有助于发现代码中的潜在问题。
5. `-S` :
   - 将源码编译成汇编代码，但不进行汇编和链接，生成.s文件。
6. **`-Wextra`**：
   - 开启额外的警告信息，比`-Wall`更严格。
7. **`-std=<standard>`**：
   - 指定使用特定的语言标准，如`-std=c99`或`-std=c++11`。
8. **`-O<level>`**：
   - 设置优化级别。`<level>`可以是0、1、2、3等。`-O0`表示无优化（默认），`-O2`和`-O3`提供更高级别的优化。
9. **`-I<dir>`**：
   - 添加头文件搜索路径。`<dir>`是头文件所在的目录。
10. **`-L<dir>`**：
    - 添加库文件搜索路径。在链接时，GCC会在这些目录中查找库文件。
11. **`-l<library>`**：
    - 链接时使用指定的库。例如，使用`-lm`来链接数学库（libm）。
12. **`-D<macro>`**：
    - 定义宏。这相当于在源代码中使用`#define`。
13. **`-fPIC`**：
    - 生成位置无关代码（Position-Independent Code），这在创建共享库时很重要。
14. **`-shared`**：
    - 创建共享库而不是可执行文件。

# GDB基本命令

GDB中常用的基本命令：

1. **`l` (list)**：
   - 列出源代码。默认情况下，它显示当前断点周围的源代码。
2. **`b` (break)**：
   - 在指定位置设置断点。例如，`b main` 在`main`函数的开始处设置断点，而`b file.c:123` 在`file.c`的第123行设置断点。
3. **`c` (continue)**：
   - 继续执行程序，直到遇到下一个断点。
4. **`r` (run)**：
   - 运行程序。如果程序已在运行中，则重新启动它。
5. **`s` (step)**：
   - 单步执行程序，进入函数内部。
6. **`n` (next)**：
   - 单步执行程序，但不进入函数内部。
7. **`p` (print)**：
   - 打印变量的值或表达式的结果。例如，`p i` 打印变量`i`的值。
8. **`bt` (backtrace)**：
   - 显示当前调用堆栈。
9. **`f` (frame)**：
   - 切换到指定的堆栈帧。
10. **`d` (delete)**：
    - 删除一个或所有断点。例如，`d 1` 删除断点1，而`d` 删除所有断点。
11. **`info`**：
    - 显示有关程序状态的各种信息，如`info breakpoints` 显示所有断点的信息。
12. **`q` (quit)**：
    - 退出GDB。
13. **`watch`**：
    - 在变量写入时设置一个监视点。
14. **`disassemble`**：
    - 反汇编当前函数或指定的代码区域。

# 条件编译

通过定义宏来条件编译

```c
#define DEBUG

int main()
{
#if DEBUG
    printf("hello world\n");
#else
    printf("hello golang\n");
#endif
}
```

方式二，通过宏的值条件编译：
```c
#define DEBUG 1

int main()
{
#if DEBUG
    printf("hello world\n");
#else
    printf("hello golang\n");
#endif
}
```

