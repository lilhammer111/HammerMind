# 字符串

## 151. 反转字符串中的单词

| 难度 | 链接                                                         | 算法 | 描述                                                         |
| ---- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 中等 | [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/) |      | 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。<br />**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 |

**解法：**

```go
func reverseWords(s string) string {
	fields := strings.Fields(s)
	for i := 0; i < len(fields)/2; i++ {
		fields[i], fields[len(fields)-1-i] = fields[len(fields)-1-i], fields[i]
	}

	return strings.Join(fields, " ")
}
```



 ## 3.无重复字符的最长子串

| 难度 | 链接                                                         | 算法               | 描述                                                         |
| ---- | ------------------------------------------------------------ | ------------------ | ------------------------------------------------------------ |
| 中等 | [3. 无重复字符的最长子串](https://leetcode.cn/problems/reverse-words-in-a-string/) | 滑动窗口（双指针） | 给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。 |

**解法：**

```go
func lengthOfLongestSubstring(s string) int {
	globalLongest := 0
	start := 0
	m := make(map[rune]int)

	for i, ch := range s {
		if v, repeated := m[ch]; repeated && v >= start {
			start = v + 1
		}
		localLongest := i - start + 1
		if localLongest > globalLongest {
			globalLongest = localLongest
		}
		m[ch] = i
	}

	return globalLongest
}
```



 ## 5.最长回文子串

| 难度 | 链接                                                         | 算法 | 描述                                                         |
| ---- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 中等 | [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) |      | 给你一个字符串 `s`，找到 `s` 中最长的回文子串。如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 |

**解法：**

```go
```



## 1143

| 难度 | 链接                                                         | 算法 | 描述                                                         |
| ---- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| 中等 | [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) |      | 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。<br />一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br />  例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。 |

 不发vv方便v方便       方便   
   cggg00000c 