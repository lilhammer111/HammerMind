# Basic

环境搭建：

操作系统 linux(ubuntu 22.04)

编译器 nasm，使用`which nasm`或者`whereis nasm`命令检查是否已安装nasm:

如果没有则安装：

```bash
sudo apt update
sudo apt install nasm
```

# Memory segment

内存段，在分段内存模型中，内存被划分为不同的“段”，每个段用于不同的目的。这种模型主要在某些类型的处理器架构中使用，例如x86架构的早期模式（如实模式和保护模式）。

在这种模型下，内存被分为至少三种主要类型的段：

1. **代码段（Code Segment）**：这部分内存用于存储程序的执行代码，即程序的指令。处理器执行的每条指令都从这个段中获取。
2. **数据段（Data Segment）**：这部分内存用于存储程序使用的变量和数据结构。程序运行时读取和存储的数据都来自这个段。
3. **堆栈段（Stack Segment）**：这部分内存用于支持程序的调用栈，包括局部变量、函数参数、返回地址等。当函数调用发生时，相关信息会被推入这个段；当函数返回时，信息被弹出。

在x86架构中，这些内存段由特定的段寄存器来引用，这些寄存器包括：

- CS（代码段寄存器）：存储代码段的起始地址。
- DS（数据段寄存器）：存储数据段的起始地址。
- SS（堆栈段寄存器）：存储堆栈段的起始地址。

除了这些基本的段，还可能有额外的段，如额外数据段（ES、FS、GS），它们可以用于引用其他的数据段。

在这种模型中，一个“段”的地址实际上由两部分组成：段寄存器的值和一个偏移量。例如，如果一个指令的地址在代码段中，那么它的完整地址将是代码段寄存器（CS）中的值加上该指令在代码段中的偏移量。

这种内存模型允许不同的程序和数据被物理上和逻辑上隔离开，提高了安全性和灵活性。不过，在现代计算中，特别是在现代操作系统中，这种分段内存管理方法已经逐渐被虚拟内存管理所取代。虽然分段仍然在某种形式上存在于现代处理器中（尤其是在启动和低级操作中），但它的使用不像在过去那样普遍了。

# Instructions

在汇编语言和机器语言级别，指令通常更具体和基础，与你提到的高级语言（如C语言或Java）中的运算符、控制流程语句（if、while、for等）和函数调用有所不同。以下是一些指令的示例：

1. **算术指令**：执行基本算术运算，如加法（ADD）、减法（SUB）、乘法（MUL）和除法（DIV）。
2. **数据传输指令**：在内存、寄存器和I/O端口之间移动数据。例如，MOV指令用于将数据从一个位置移动到另一个位置。
3. **控制流程指令**：改变程序的执行流程。这些指令包括跳转（JMP）、条件分支（如JZ、JNZ，即“如果为零则跳转”、“如果非零则跳转”）和函数调用（CALL）及返回（RET）。
4. **逻辑指令**：执行逻辑运算，如AND、OR、XOR和NOT。
5. **比较指令**：比较两个值（比如CMP指令）并设置处理器的状态标志，根据这些标志可以执行后续的条件跳转指令。

举个例子，一个简单的汇编语言指令可能如下：

```assembly
MOV AX, 1  ; 将数字1移动到寄存器AX中
ADD AX, 2  ; 将寄存器AX中的值与2相加
```

在这个例子中，`MOV`和`ADD`是指令，而`AX`、`1`和`2`是这些指令的操作数。不同于高级编程语言中的函数调用的括号，汇编语言和机器语言的指令通常不使用括号来表示函数调用。相反，函数调用和返回通常由特定的指令（如CALL和RET）来处理。

因此，当我们谈论“加程序的指令”时，我们指的是构成程序的这些基本操作命令，而不是高级编程语言中的符号或结构。

# Registers

IA-32 架构中有 10 个 32 位和 6 个 16 位处理器寄存器。 寄存器分为三类

- 通用寄存器
- 控制寄存器
- 段寄存器

通用寄存器又分为：

- 数据寄存器
- 指针寄存器
- 索引寄存器



# 数据寄存器

在IA-32（Intel Architecture, 32-bit）架构中，数据寄存器主要用于临时存储数据，这些数据可以是指令操作的结果、用于算术运算的操作数、或者其他类型的数据。IA-32架构设计了一组通用数据寄存器，这些寄存器在执行各种操作时提供了高效的数据访问和存储能力。这些数据寄存器包括：

1. **EAX** - 累加器寄存器（Accumulator Register）：主要用于算术运算、数据传输指令、以及某些特定的操作指令。
2. **EBX** - 基址寄存器（Base Register）：通常用于作为内存地址的基点，在内存寻址时使用。
3. **ECX** - 计数器寄存器（Count Register）：主要用于循环操作中的计数，如字符串和循环指令。
4. **EDX** - 数据寄存器（Data Register）：在进行某些类型的运算时用于存储数据或操作数，例如在乘法和除法运算中。

这些32位寄存器都是16位寄存器（AX、BX、CX、DX）的扩展，允许在32位操作模式中使用。它们的高16位（即32位寄存器的上半部分）可以单独访问，而它们的低16位（即原始的16位寄存器）也可以作为独立的单元使用。此外，这些16位寄存器的低8位（例如，AX的低8位是AL，BX的低8位是BL等）也可以单独访问，提供了灵活的数据处理能力。

![数据寄存器](https://www.w3schools.cn/assembly/images/register1.jpg)

> EAX,EBX...中的E是extended的意思
>
> AH,AL...中的H代表High表示高八位，L代表Low表示低八位



# 指针寄存器

在IA-32架构（以及其他许多计算机架构）中，指针寄存器是一类专门用来==存储内存地址==的寄存器。这些寄存器可以指向程序中的数据或者一段特定的代码位置，使得处理器能够访问和操作内存中的数据。指针寄存器在执行数组操作、字符串处理、函数调用等操作时尤其重要。

在IA-32架构中，主要有以下几种指针寄存器：

1. **指令指针寄存器（Instruction Pointer Register）**：
   - **EIP（Extended Instruction Pointer）**：这个32位寄存器存储着下一条要执行的指令的地址。在程序执行过程中，EIP自动更新，指向当前代码段中的下一条指令。
2. **栈指针寄存器（Stack Pointer Register）**：
   - **ESP（Extended Stack Pointer）**：这个32位寄存器指向程序栈顶部的当前位置。在进行函数调用、返回以及局部变量存储时，ESP用于追踪栈的顶端。
3. **基指针寄存器（Base Pointer Register）**：
   - **EBP（Extended Base Pointer）**：这个32位寄存器通常用于指向栈帧的底部，使得函数内的局部变量和参数可以通过相对于EBP的偏移来访问。EBP的使用可以使栈的内容在函数调用过程中保持可访问。
4. **源索引寄存器和目的索引寄存器**：
   - **ESI（Extended Source Index）**：通常用于指向数据传输操作的源位置。
   - **EDI（Extended Destination Index）**：通常用于指向数据传输操作的目标位置。

这些指针寄存器在汇编语言和系统级编程中非常重要，它们使得程序能够高效地管理内存和执行复杂的数据操作。通过使用这些寄存器，程序可以实现诸如数据复制、字符串处理、函数调用和返回等操作，同时保持对内存结构的精确控制。



















































