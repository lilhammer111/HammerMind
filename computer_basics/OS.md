# 操作系统内核核心组件

1. **进程管理（Process Management）**：
   - 负责创建、调度、同步和终止进程和线程。
   - 包括进程调度、进程间通信（IPC）、进程同步等。
2. **内存管理（Memory Management）**：
   - 管理物理内存和虚拟内存，包括内存分配和回收。
   - 负责内存寻址、分页、分段和换页等。
3. **文件系统（File System）**：
   - 管理文件的存储、检索和组织。
   - 提供文件创建、删除、读写、权限管理等功能。
4. **设备驱动（Device Drivers）**：
   - 提供硬件设备的抽象层，允许操作系统和硬件设备进行交互。
   - 包括输入/输出管理、设备控制等。
5. **网络管理（Network Management）**：
   - 处理网络相关的操作，如数据传输、网络连接和协议栈。
6. **安全机制（Security Mechanism）**：
   - 提供用户认证、访问控制、审计和加密等安全功能。
7. **系统调用接口（System Call Interface）**：
   - 提供一组接口，允许用户空间的程序请求内核提供的服务。

# 内核态和用户态

内核态和用户态的意义在于，有一些属于“特权指令”的机器指令可能会涉及到一些比较严重的操作比如说内存清零，这个必不可能让普通程序也轻松的使用，所以想使用这样的特权指令，程序就必须陷入内核态。

内核态和用户态的区分，可以让cpu有把握地执行某些特权指令。

cpu中有一个程序状态字寄存器(PSW)，这个寄存器中有一个二进制位用于表示cpu处于内核态还是用户态。

# 中断

中断是一个信号，用于指示CPU停止当前工作去处理别的操作。

中断是CPU从用户态转为内核态的唯一方式。

中断分为内中断和外中断， 由当前指令引起的中断就是内中断，又叫**异常**，如程序错误（除零，非法使用特权指令，这些都属于Abort终止），系统调用（属于trap陷入）等等。

CPU每执行完一个指令都会例行检查是否有外部中断信号需要处理。

# 时钟中断

操作系统的时钟部件会每隔一段时间给CPU发一个中断信号，让操作系统周期性地获取CPU资源，从而使得操作系统可以进行各种管理和调度工作 。

比如抢占式调度就是基于时钟中断实现的。

除了进程调度，时钟中断还可以用于更新系统时钟、执行定时任务等。

# IO中断

IO中断是由IO设备，比如磁盘，打印机，USB等设备向CPU发送一个中断信号，请求CPU来处理某个IO操作。

# 中断向量表

不同的中断信号需要不同的中断程序来处理，CPU检测到中断信号后会查表进而来处理中断信号。

# 系统调用

系统调用就是操作系统提供给应用程序的服务，以接口形式，LINUX中有以下这些接口：

1. **文件和目录操作**：
   - `open`：打开文件
   - `read`：读取文件
   - `write`：写入文件
   - `close`：关闭文件
   - `lseek`：移动文件读/写位置
   - `mkdir`：创建目录
   - `rmdir`：删除目录
   - `unlink`：删除文件
2. **进程控制**：
   - `fork`：创建新进程
   - `exit`：结束进程执行
   - `wait`：等待进程结束
   - `execve`：执行程序
   - `getpid`：获取进程ID
   - `kill`：发送信号给进程
3. **内存管理**：
   - `brk`、`sbrk`：管理堆内存
   - `mmap`：映射文件或设备到内存
   - `munmap`：取消内存映射
4. **网络通信**：
   - `socket`：创建套接字
   - `bind`：绑定套接字到地址
   - `listen`、`accept`：监听和接受连接
   - `connect`：建立连接
   - `send`、`recv`：发送和接收数据
5. **用户和组管理**：
   - `getuid`：获取用户ID
   - `getgid`：获取组ID
   - `setuid`：设置用户ID
   - `setgid`：设置组ID
6. **权限控制**：
   - `chmod`：改变文件权限
   - `chown`：改变文件所有者
7. **时间管理**：
   - `time`：获取时间
   - `nanosleep`：高精度休眠
8. **信号处理**：
   - `signal`：设置信号处理函数
   - `sigaction`：检查或修改信号处理

高级编程语言会封装系统调用的接口，并以标准库的形式提供给开发者进行调用，比如c中：

```c
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

int main() {
    int fd;
    char buffer[100];

    // 打开文件
    fd = open("example.txt", O_RDONLY);
    if (fd == -1) {
        perror("Error opening file");
        return -1;
    }

    // 读取文件
    read(fd, buffer, sizeof(buffer));

    // 写入文件（需要文件以写入模式打开）
    // write(fd, buffer, sizeof(buffer));

    // 关闭文件
    close(fd);

    return 0;
}
```

# 陷入指令

用户程序主动触发中断，并将CPU从用户态转为内核态，目的是为了请求操作系统提供某些特定的服务，比如系统调用。

# 操作系统原语

原语的原是指原子性，应该被完整执行的程序，而不可以只执行部分。

操作系统原语就是一些实现操作系统核心功能的内核程序，比如，创建新进程，终止进程，内存分配，地址转换，文件操作，目录操作，磁盘I/O请求等等。

# 大内核结构

包含了大部分操作系统功能，一个组件崩溃，操作系统崩溃，安全性低，进程间通信开销少，性能高，LINUX和大多数UNIX都是大内核。

# 微内核结构

只有基础操作系统功能，MINIX和早起的Mac OS。

# 分层结构

将操作系统功能分层，并且只能调用相邻层次的接口，优点便于调试，缺点跨层次调用性能低。

# 模块化结构

# 外核结构 

外核将底层硬件资源直接暴露给用户应用程序，但同时又保证基本的安全和资源隔离。

# 操作系统引导

1. **加电（Power On）**:
   - 当计算机加电后，处理器开始执行存储在主板上的ROM芯片（通常是BIOS或UEFI固件）中的指令。
2. **自检（Power-On Self-Test, POST）**:
   - BIOS或UEFI执行自检，检查计算机的基础硬件，如内存、键盘和存储设备。
   - 如果检测到硬件错误，可能会发出声音信号或显示错误信息。
3. **查找启动设备**:
   - BIOS/UEFI根据预设的启动顺序，从可能的设备（硬盘、SSD、光驱、USB设备等）中查找可引导的媒体。
   - 这通常涉及读取设备的MBR（主引导记录）或GPT（GUID分区表）来找到引导加载程序。
4. **加载引导加载程序（Bootloader）**:
   - 一旦找到有效的引导加载程序（如GRUB、LILO等），BIOS/UEFI将控制权交给这个程序。
   - 引导加载程序负责加载操作系统。在多操作系统的情况下，它可能会提供一个菜单供用户选择。
5. **操作系统加载**:
   - 引导加载程序从硬盘读取操作系统的内核，加载到内存中。
   - 然后，它将控制权交给操作系统内核，开始初始化操作系统。
6. **操作系统初始化**:
   - 操作系统内核初始化各种系统组件，如驱动程序、系统服务和应用程序。
   - 它设置虚拟内存、网络配置、用户界面等。
7. **用户登录**:
   - 操作系统加载完成后，显示登录界面，等待用户输入凭据（用户名和密码）。
   - 用户登录后，加载用户配置的桌面环境或应用程序。

# 虚拟机管理程序

虚拟机管理程序（Virtual Machine Monitor，VMM），也称为虚拟机监视器或者简称为“hypervisor”。

虚拟机管理程序主要有两种类型：

1. **类型 1（裸金属）虚拟机管理程序**：直接运行在物理硬件上，提供高性能和效率。例如，VMware ESXi、Microsoft Hyper-V和Xen。
2. **类型 2（宿主式）虚拟机管理程序**：运行在传统的操作系统之上。例如，VMware Workstation、Oracle VirtualBox和Parallels Desktop。

# PCB

Process Control Block，进程控制块。

操作系统每创建一个进程都会创建一个对应的PCB。

PCB主要包括以下信息：

1. **进程标识符（Process ID, PID）**:
   - 每个进程的唯一标识符。
2. **进程状态**:
   - 进程的当前状态，如运行（Running）、就绪（Ready）、等待（Waiting）或终止（Terminated）。
3. **程序计数器**:
   - 指示进程将要执行的下一条指令的地址。
4. **CPU寄存器信息**:
   - 包括累加器、索引寄存器、栈指针和通用寄存器等的当前值。
5. **CPU调度信息**:
   - 与调度有关的信息，如进程优先级、调度队列指针和其他调度参数。
6. **内存管理信息**:
   - 进程的地址空间信息，如页表、段表、内存限制等。
7. **账户信息**:
   - CPU使用时间、实际使用时间和其他资源使用信息。
8. **I/O状态信息**:
   - 包括分配给进程的I/O设备列表、打开文件的列表等。

当操作系统切换进程（在多任务操作中非常常见）时，它会使用PCB来保存当前进程的状态，并从另一进程的PCB中恢复其状态，这个过程被称为**上下文切换**（Context Switching）。

# 程序段

程序段，也称为文本段(text segment)，包含程序的执行代码。这是进程执行的实际指令集合。

程序段通常是只读的，以防止运行时修改程序代码。

# 数据段

数据段(data segment)用于存储程序运行时使用的数据，包括全局变量、静态变量等。与程序段不同，数据段是可读写的。

数据段可以进一步细分为初始化的数据段（存储明确赋值的变量）和未初始化的数据段（BSS段，存储未赋初值的全局变量和静态变量）。

# 堆段

堆段(heap segment)用于动态内存分配，程序运行时可以在堆上分配或释放内存。

堆的大小不是固定的，可以根据需要动态增长和收缩。

# 栈段

栈段(Stack Segment)用于存储局部变量、函数参数和返回地址。

每当函数调用发生时，相关信息就会被压入栈中；函数返回时，这些信息又会被弹出。

# 进程状态

进程主要状态包括：

1. **新建（New）**:
   - 进程刚刚被创建，正在初始化，例如分配PID和必要的资源。
2. **就绪（Ready）**:
   - 进程已准备好运行，并等待CPU时间。在这个状态下，进程已经加载到主存中，但由于其他进程正在运行，它暂时还不能执行。
3. **运行（Running）**:
   - 进程正在CPU上执行。在这个状态下，进程正在使用CPU进行实际的计算或执行代码。
4. **等待（Waiting）或阻塞（Blocked）**:
   - 进程因等待某个事件（如I/O操作完成、信号或资源可用）而暂停执行。在这个状态下，即使CPU可用，进程也不能执行。
5. **终止（Terminated）或退出（Exited）**:
   - 进程已完成执行或被操作系统强制终止。在这个状态下，进程释放了它占用的所有资源，包括内存和打开的文件。

操作系统可能还会定义更多的子状态或特殊状态，例如：

- **就绪挂起（Ready Suspended）**：进程在外存中等待运行，通常是由于内存资源不足。
- **阻塞挂起（Blocked Suspended）**：进程因等待某个事件而被挂起，同时被移出主存。

进程状态的转换通常由操作系统的调度程序（scheduler）和进程自身的行为触发。

# 关中断指令

关中断指令使得CPU不再在每条指令执行完成后检查是否有外部中断信号。

# 开中断指令

反之。

# POSIX

POSIX（可移植操作系统接口，Portable Operating System Interface）是一个由IEEE（电气和电子工程师协会）为了提高软件在各种UNIX操作系统之间的兼容性而制定的一系列标准的集合。

# IPC

Inter-Process Communication，进程间通信。

常见的IPC机制：

1. **管道（Pipes）**：
   - 管道是最简单的IPC形式之一，允许一个进程的输出成为另一个进程的输入。通常分为匿名管道和命名管道（FIFO）。
2. **消息队列（Message Queues）**：
   - 消息队列允许进程以消息的形式交换数据。这些消息存储在队列中，直到被接收进程读取。
3. **信号（Signals）**：
   - 信号是一种用于进程间通信的简单机制，允许进程对其他进程发送简单的通知。
4. **共享内存（Shared Memory）**：
   - 共享内存允许两个或多个进程共享一块物理内存，是最快的IPC方法之一。
5. **信号量（Semaphores）**：
   - 信号量主要用于同步进程间的活动，确保资源的安全访问。
6. **套接字（Sockets）**：
   - 套接字主要用于不同主机上的进程间通信，但也可用于同一主机上的进程间通信。
7. **内存映射文件（Memory-Mapped Files）**：
   - 这种机制允许文件内容被映射到进程的地址空间中，从而实现进程间的数据共享。

# 共享内存

将共享内存区映射到进程自己的地址空间。

共享可分为基于数据结构和基于存储区的共享。

# 消息传递

通过“发送消息”和“接收消息”这两个原语进行数据交换。

分为直接发送和信箱发送哪种模式。

# 线程相比进程减少的开销

线程切换相比进程切换减少的上下文开销主要体现在以下方面：

1. **地址空间切换**：
   - 进程切换需要切换整个进程的地址空间，包括加载新进程的页表到内存管理单元（MMU）。这是一个成本较高的操作，因为涉及到底层的硬件操作。
   - 线程切换则不需要这样做，因为同一进程的所有线程共享相同的地址空间。
2. **全局变量和堆内存**：
   - 进程间不共享全局变量和堆内存，每个进程有自己的独立全局变量和堆空间。在进程切换时，这些数据的上下文需要保存和恢复。
   - 线程间共享这些内存区域，所以线程切换不需要涉及全局变量和堆内存的保存和恢复。
3. **打开的文件和资源**：
   - 进程间各自维护自己的文件描述符表和其他系统资源。进程切换时，需要处理这些资源的上下文。
   - 线程共享其所属进程的文件描述符和资源，因此线程切换不涉及这些资源的变更。
4. **系统内核数据结构**：
   - 进程拥有独立的内核数据结构，如进程控制块（PCB）。进程切换需要更新这些数据结构。
   - 线程共享所属进程的内核数据结构，线程切换仅涉及线程自己的数据结构（如线程控制块）。

# goroutine相比线程减少的开销

Go语言中的协程（goroutine）相比于传统线程减少的开销主要体现在以下几个方面：

1. **更小的堆栈大小**：
   - 线程通常有一个相对较大的初始堆栈大小（例如，1MB）。
   - Go协程开始时的堆栈大小非常小（几KB），并且可以根据需要动态增长和缩小。这使得在相同的内存空间中可以运行更多的协程。
2. **调度开销**：
   - 线程是由操作系统内核进行调度的，这可能涉及复杂的上下文切换和调度决策。
   - Go协程由Go运行时（runtime）调度，这是一种用户级的轻量级调度，不涉及到内核级的上下文切换，因此开销更小。
3. **创建和销毁的效率**：
   - 创建和销毁线程相对较慢，因为这需要操作系统内核的直接参与。
   - Go协程的创建和销毁非常快速，因为这些操作完全在用户空间完成，无需操作系统内核的干预。
4. **内存开销**：
   - 线程的内存开销主要来自较大的堆栈和线程的内核数据结构。
   - Go协程的内存开销主要是其堆栈，由于堆栈大小动态调整，因此更加高效。
5. **并发编程模型**：
   - 线程模型通常需要开发者处理同步和互斥，这可能会引入复杂性和潜在的错误。
   - Go协程和通道（channel）提供了一种更简单的并发模型，有助于减少死锁和竞争条件等问题。

# TCB

Thread Control Block，线程控制块。

# ULT

User-Level Thread，用户级线程。

可以理解成伪线程，从操作系统视角，只能看到一个进程，时间片还是按照进程分配的，因此无法并行。

# KLT

Kernel-Level Thread，内核级线程。

# 多线程模型

常见的多线程模型

1. **一对一模型**：
   - 每个线程映射到一个内核线程。这种模型提供了最好的并行性，但线程的创建和管理开销较高。
   - 例子：Linux、Windows。
2. **多对一模型**：
   - 多个用户级线程映射到一个内核线程。这种模型中，线程管理在用户空间进行，开销较小，但一个线程的阻塞会阻塞整个进程。
   - 例子：早期的Green Threads实现。
3. **多对多模型**：
   - 多个用户级线程映射到多个内核线程。这种模型结合了一对一和多对一模型的优点，实现了良好的并行性和效率。
   - 例子：Solaris的轻量级进程（LWP）。

# 高级调度

又叫作业调度，从辅存中挑选一个作业调入内存执行。

# 低级调度

又叫进程调度，决定内存内哪个就绪进程上CPU执行。

简单理解为时间片分配给谁。

# 中级调度

又叫内存调度，是指当内存不够的时候，将某些不重要的进程暂时调到辅存上，进程进入挂起状态。 

# 临界区

操作系统中的临界区（Critical Section）是指一个多线程或多进程环境中，访问共享资源（如共享内存、共享文件等）的那部分程序代码。在任何给定时间内，只有一个线程或进程应该被允许进入临界区执行，以防止数据不一致或竞态条件。

临界区的理解：

1. **临界区是代码段**：
   - 临界区指的是程序中的一段代码，这段代码访问了共享资源（如共享内存、共享文件等）。
2. **执行临界区的代码**：
   - 当我们说一个线程或进程“进入临界区”，实际上是指它开始执行这段代码。这意味着该线程或进程在操作共享资源。
3. **互斥执行**：
   - 为了防止数据冲突或竞态条件，需要确保任何时刻只有一个线程或进程在执行临界区的代码。

# 抢占式调度

抢占式调度是一种调度机制，允许操作系统中断当前正在执行的进程，以便将CPU资源分配给其他进程。这种中断通常是基于某些策略，如时间片用尽、出现高优先级的进程等。

进程调度的方式可以按照操作系统是否能中断当前进程分为抢占式调度和非抢占式调度，对于非抢占式调度，操作系统不会主动中断进程的执行，除非进程自己中断。

# 闲逛进程 

也叫空转进程。

# CPU利用率

**CPU利用率** = （CPU忙碌时间 / 总时间）× 100%

# 系统吞吐量

单位时间内系统完成的任务数、处理的数据量或完成的操作次数。

应用场景：

- **服务器和数据中心**：评估服务器处理请求的能力。

- **网络系统**：衡量网络传输数据的速率。

- **数据库系统**：测量数据库每秒能处理的事务或查询数量。

# 周转时间

作业完成时长。

周转时间通常包括以下几个部分：

1. **等待时间**：作业在就绪队列中等待被调度的时间。
2. **服务时间**：作业在CPU上执行的实际时间。
3. **I/O时间**：作业执行过程中进行输入/输出操作所花费的时间。
4. **其他系统时间**：如作业在进行其他系统操作（如内存访问）所花费的时间。

# 调度算法

常见的调度算法：

1. **先来先服务（FCFS, First-Come, First-Served）**：
   - 最简单的调度算法，按照进程到达的顺序进行调度。
   - 优点是实现简单；缺点是平均等待时间可能较长。
2. **短作业优先（SJF, Shortest Job First）**：
   - 优先调度预计运行时间最短的进程。
   - 可以是非抢占式的，也可以是抢占式的（称为最短剩余时间优先，SRTF）。
   - 缺点是难以准确知道进程的运行时间，且可能导致长作业饥饿。
3. **轮转调度（RR, Round Robin）**：
   - 每个进程被分配一个时间片，用完时间片后如果未完成就排到队列末尾。
   - 适用于时间共享系统，提供响应性良好的交互环境。
   - 时间片的大小会影响系统性能。
4. **优先级调度**：
   - 根据进程的优先级来调度，优先级高的先执行。
   - 可以是非抢占式的或抢占式的。
   - 缺点是低优先级进程可能饥饿。
5. **多级队列调度**：
   - 将进程分配到不同的队列中，每个队列有自己的调度算法。
   - 通常每个队列代表不同的优先级。
6. **多级反馈队列**：
   - 动态地调整进程的优先级。
   - 包含多个队列，优先级不同，时间片大小不同。
   - 试图平衡作业周转时间和响应时间。
7. **实时调度**：
   - 用于实时系统，确保关键任务及时完成。
   - 包括硬实时调度和软实时调度。

# Linux的调度算法

到目前为止，Linux主要使用了以下几种调度算法：

1. **O(1)调度器**：
   - 早期的Linux 2.4和部分2.6版本使用的调度器。
   - 提供了常数时间的调度决策（即与进程数量无关），但在处理交互式进程方面表现不佳。
2. **完全公平调度器（CFS, Completely Fair Scheduler）**：
   - 从Linux 2.6.23版本开始引入。
   - 基于红黑树实现，旨在提供更好的交互性能和整体性能，尤其是在多核处理器上。
   - CFS使用虚拟运行时间来表示进程的公平性，尽量让每个进程获得相等的CPU时间。
3. **实时调度器（RT Scheduler）**：
   - Linux还包含实时调度器，用于特定的实时应用。
   - 提供了FIFO（先进先出）和RR（轮转）两种实时调度策略。
4. **Deadline调度器**：
   - 在更近期的Linux版本中引入。
   - 用于确保任务在特定的截止时间前完成。
   - 适用于对时间敏感的任务。















































































































