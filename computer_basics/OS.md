# 操作系统内核核心组件

1. **进程管理（Process Management）**：
   - 负责创建、调度、同步和终止进程和线程。
   - 包括进程调度、进程间通信（IPC）、进程同步等。
2. **内存管理（Memory Management）**：
   - 管理物理内存和虚拟内存，包括内存分配和回收。
   - 负责内存寻址、分页、分段和换页等。
3. **文件系统（File System）**：
   - 管理文件的存储、检索和组织。
   - 提供文件创建、删除、读写、权限管理等功能。
4. **设备驱动（Device Drivers）**：
   - 提供硬件设备的抽象层，允许操作系统和硬件设备进行交互。
   - 包括输入/输出管理、设备控制等。
5. **网络管理（Network Management）**：
   - 处理网络相关的操作，如数据传输、网络连接和协议栈。
6. **安全机制（Security Mechanism）**：
   - 提供用户认证、访问控制、审计和加密等安全功能。
7. **系统调用接口（System Call Interface）**：
   - 提供一组接口，允许用户空间的程序请求内核提供的服务。

# 内核态和用户态

内核态和用户态的意义在于，有一些属于“特权指令”的机器指令可能会涉及到一些比较严重的操作比如说内存清零，这个必不可能让普通程序也轻松的使用，所以想使用这样的特权指令，程序就必须陷入内核态。

内核态和用户态的区分，可以让cpu有把握地执行某些特权指令。

cpu中有一个程序状态字寄存器(PSW)，这个寄存器中有一个二进制位用于表示cpu处于内核态还是用户态。

# 中断

中断是一个信号，用于指示CPU停止当前工作去处理别的操作。

中断是CPU从用户态转为内核态的唯一方式。

中断分为内中断和外中断， 由当前指令引起的中断就是内中断，又叫**异常**，如程序错误（除零，非法使用特权指令，这些都属于Abort终止），系统调用（属于trap陷入）等等。

CPU每执行完一个指令都会例行检查是否有外部中断信号需要处理。

# 时钟中断

操作系统的时钟部件会每隔一段时间给CPU发一个中断信号，让操作系统周期性地获取CPU资源，从而使得操作系统可以进行各种管理和调度工作 。

比如抢占式调度就是基于时钟中断实现的。

除了进程调度，时钟中断还可以用于更新系统时钟、执行定时任务等。

# IO中断

IO中断是由IO设备，比如磁盘，打印机，USB等设备向CPU发送一个中断信号，请求CPU来处理某个IO操作。

# 中断向量表

不同的中断信号需要不同的中断程序来处理，CPU检测到中断信号后会查表进而来处理中断信号。

# 系统调用

系统调用就是操作系统提供给应用程序的服务，以接口形式，LINUX中有以下这些接口：

1. **文件和目录操作**：
   - `open`：打开文件
   - `read`：读取文件
   - `write`：写入文件
   - `close`：关闭文件
   - `lseek`：移动文件读/写位置
   - `mkdir`：创建目录
   - `rmdir`：删除目录
   - `unlink`：删除文件
2. **进程控制**：
   - `fork`：创建新进程
   - `exit`：结束进程执行
   - `wait`：等待进程结束
   - `execve`：执行程序
   - `getpid`：获取进程ID
   - `kill`：发送信号给进程
3. **内存管理**：
   - `brk`、`sbrk`：管理堆内存
   - `mmap`：映射文件或设备到内存
   - `munmap`：取消内存映射
4. **网络通信**：
   - `socket`：创建套接字
   - `bind`：绑定套接字到地址
   - `listen`、`accept`：监听和接受连接
   - `connect`：建立连接
   - `send`、`recv`：发送和接收数据
5. **用户和组管理**：
   - `getuid`：获取用户ID
   - `getgid`：获取组ID
   - `setuid`：设置用户ID
   - `setgid`：设置组ID
6. **权限控制**：
   - `chmod`：改变文件权限
   - `chown`：改变文件所有者
7. **时间管理**：
   - `time`：获取时间
   - `nanosleep`：高精度休眠
8. **信号处理**：
   - `signal`：设置信号处理函数
   - `sigaction`：检查或修改信号处理

高级编程语言会封装系统调用的接口，并以标准库的形式提供给开发者进行调用，比如c中：

```c
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdio.h>

int main() {
    int fd;
    char buffer[100];

    // 打开文件
    fd = open("example.txt", O_RDONLY);
    if (fd == -1) {
        perror("Error opening file");
        return -1;
    }

    // 读取文件
    read(fd, buffer, sizeof(buffer));

    // 写入文件（需要文件以写入模式打开）
    // write(fd, buffer, sizeof(buffer));

    // 关闭文件
    close(fd);

    return 0;
}
```

# 陷入指令

用户程序主动触发中断，并将CPU从用户态转为内核态，目的是为了请求操作系统提供某些特定的服务，比如系统调用。

# 操作系统原语

原语的原是指原子性，应该被完整执行的程序，而不可以只执行部分。

操作系统原语就是一些实现操作系统核心功能的内核程序，比如，创建新进程，终止进程，内存分配，地址转换，文件操作，目录操作，磁盘I/O请求等等。

# 大内核结构

包含了大部分操作系统功能，一个组件崩溃，操作系统崩溃，安全性低，进程间通信开销少，性能高，LINUX和大多数UNIX都是大内核。

# 微内核结构

只有基础操作系统功能，MINIX和早起的Mac OS。

# 分层结构

将操作系统功能分层，并且只能调用相邻层次的接口，优点便于调试，缺点跨层次调用性能低。

# 模块化结构

# 外核结构 

外核将底层硬件资源直接暴露给用户应用程序，但同时又保证基本的安全和资源隔离。

# 操作系统引导

1. **加电（Power On）**:
   - 当计算机加电后，处理器开始执行存储在主板上的ROM芯片（通常是BIOS或UEFI固件）中的指令。
2. **自检（Power-On Self-Test, POST）**:
   - BIOS或UEFI执行自检，检查计算机的基础硬件，如内存、键盘和存储设备。
   - 如果检测到硬件错误，可能会发出声音信号或显示错误信息。
3. **查找启动设备**:
   - BIOS/UEFI根据预设的启动顺序，从可能的设备（硬盘、SSD、光驱、USB设备等）中查找可引导的媒体。
   - 这通常涉及读取设备的MBR（主引导记录）或GPT（GUID分区表）来找到引导加载程序。
4. **加载引导加载程序（Bootloader）**:
   - 一旦找到有效的引导加载程序（如GRUB、LILO等），BIOS/UEFI将控制权交给这个程序。
   - 引导加载程序负责加载操作系统。在多操作系统的情况下，它可能会提供一个菜单供用户选择。
5. **操作系统加载**:
   - 引导加载程序从硬盘读取操作系统的内核，加载到内存中。
   - 然后，它将控制权交给操作系统内核，开始初始化操作系统。
6. **操作系统初始化**:
   - 操作系统内核初始化各种系统组件，如驱动程序、系统服务和应用程序。
   - 它设置虚拟内存、网络配置、用户界面等。
7. **用户登录**:
   - 操作系统加载完成后，显示登录界面，等待用户输入凭据（用户名和密码）。
   - 用户登录后，加载用户配置的桌面环境或应用程序。

# 虚拟机管理程序

虚拟机管理程序（Virtual Machine Monitor，VMM），也称为虚拟机监视器或者简称为“hypervisor”。

虚拟机管理程序主要有两种类型：

1. **类型 1（裸金属）虚拟机管理程序**：直接运行在物理硬件上，提供高性能和效率。例如，VMware ESXi、Microsoft Hyper-V和Xen。
2. **类型 2（宿主式）虚拟机管理程序**：运行在传统的操作系统之上。例如，VMware Workstation、Oracle VirtualBox和Parallels Desktop。

# PCB

Process Control Block，进程控制块。

操作系统每创建一个进程都会创建一个对应的PCB。

PCB主要包括以下信息：

1. **进程标识符（Process ID, PID）**:
   - 每个进程的唯一标识符。
2. **进程状态**:
   - 进程的当前状态，如运行（Running）、就绪（Ready）、等待（Waiting）或终止（Terminated）。
3. **程序计数器**:
   - 指示进程将要执行的下一条指令的地址。
4. **CPU寄存器信息**:
   - 包括累加器、索引寄存器、栈指针和通用寄存器等的当前值。
5. **CPU调度信息**:
   - 与调度有关的信息，如进程优先级、调度队列指针和其他调度参数。
6. **内存管理信息**:
   - 进程的地址空间信息，如页表、段表、内存限制等。
7. **账户信息**:
   - CPU使用时间、实际使用时间和其他资源使用信息。
8. **I/O状态信息**:
   - 包括分配给进程的I/O设备列表、打开文件的列表等。

当操作系统切换进程（在多任务操作中非常常见）时，它会使用PCB来保存当前进程的状态，并从另一进程的PCB中恢复其状态，这个过程被称为**上下文切换**（Context Switching）。

# 程序段

程序段，也称为文本段(text segment)，包含程序的执行代码。这是进程执行的实际指令集合。

程序段通常是只读的，以防止运行时修改程序代码。

# 数据段

数据段(data segment)用于存储程序运行时使用的数据，包括全局变量、静态变量等。与程序段不同，数据段是可读写的。

数据段可以进一步细分为初始化的数据段（存储明确赋值的变量）和未初始化的数据段（BSS段，存储未赋初值的全局变量和静态变量）。

# 堆段

堆段(heap segment)用于动态内存分配，程序运行时可以在堆上分配或释放内存。

堆的大小不是固定的，可以根据需要动态增长和收缩。

# 栈段

栈段(Stack Segment)用于存储局部变量、函数参数和返回地址。

每当函数调用发生时，相关信息就会被压入栈中；函数返回时，这些信息又会被弹出。

# 进程状态

进程主要状态包括：

1. **新建（New）**:
   - 进程刚刚被创建，正在初始化，例如分配PID和必要的资源。
2. **就绪（Ready）**:
   - 进程已准备好运行，并等待CPU时间。在这个状态下，进程已经加载到主存中，但由于其他进程正在运行，它暂时还不能执行。
3. **运行（Running）**:
   - 进程正在CPU上执行。在这个状态下，进程正在使用CPU进行实际的计算或执行代码。
4. **等待（Waiting）或阻塞（Blocked）**:
   - 进程因等待某个事件（如I/O操作完成、信号或资源可用）而暂停执行。在这个状态下，即使CPU可用，进程也不能执行。
5. **终止（Terminated）或退出（Exited）**:
   - 进程已完成执行或被操作系统强制终止。在这个状态下，进程释放了它占用的所有资源，包括内存和打开的文件。

操作系统可能还会定义更多的子状态或特殊状态，例如：

- **就绪挂起（Ready Suspended）**：进程在外存中等待运行，通常是由于内存资源不足。
- **阻塞挂起（Blocked Suspended）**：进程因等待某个事件而被挂起，同时被移出主存。

进程状态的转换通常由操作系统的调度程序（scheduler）和进程自身的行为触发。

# 关中断指令

关中断指令使得CPU不再在每条指令执行完成后检查是否有外部中断信号。

# 开中断指令

反之。

# POSIX

POSIX（可移植操作系统接口，Portable Operating System Interface）是一个由IEEE（电气和电子工程师协会）为了提高软件在各种UNIX操作系统之间的兼容性而制定的一系列标准的集合。

# IPC

Inter-Process Communication，进程间通信。

常见的IPC机制：

1. **管道（Pipes）**：
   - 管道是最简单的IPC形式之一，允许一个进程的输出成为另一个进程的输入。通常分为匿名管道和命名管道（FIFO）。
2. **消息队列（Message Queues）**：
   - 消息队列允许进程以消息的形式交换数据。这些消息存储在队列中，直到被接收进程读取。
3. **信号（Signals）**：
   - 信号是一种用于进程间通信的简单机制，允许进程对其他进程发送简单的通知。
4. **共享内存（Shared Memory）**：
   - 共享内存允许两个或多个进程共享一块物理内存，是最快的IPC方法之一。
5. **信号量（Semaphores）**：
   - 信号量主要用于同步进程间的活动，确保资源的安全访问。
6. **套接字（Sockets）**：
   - 套接字主要用于不同主机上的进程间通信，但也可用于同一主机上的进程间通信。
7. **内存映射文件（Memory-Mapped Files）**：
   - 这种机制允许文件内容被映射到进程的地址空间中，从而实现进程间的数据共享。

# 共享内存

将共享内存区映射到进程自己的地址空间。

共享可分为基于数据结构和基于存储区的共享。

# 消息传递

通过“发送消息”和“接收消息”这两个原语进行数据交换。

分为直接发送和信箱发送哪种模式。

# 线程相比进程减少的开销

线程切换相比进程切换减少的上下文开销主要体现在以下方面：

1. **地址空间切换**：
   - 进程切换需要切换整个进程的地址空间，包括加载新进程的页表到内存管理单元（MMU）。这是一个成本较高的操作，因为涉及到底层的硬件操作。
   - 线程切换则不需要这样做，因为同一进程的所有线程共享相同的地址空间。
2. **全局变量和堆内存**：
   - 进程间不共享全局变量和堆内存，每个进程有自己的独立全局变量和堆空间。在进程切换时，这些数据的上下文需要保存和恢复。
   - 线程间共享这些内存区域，所以线程切换不需要涉及全局变量和堆内存的保存和恢复。
3. **打开的文件和资源**：
   - 进程间各自维护自己的文件描述符表和其他系统资源。进程切换时，需要处理这些资源的上下文。
   - 线程共享其所属进程的文件描述符和资源，因此线程切换不涉及这些资源的变更。
4. **系统内核数据结构**：
   - 进程拥有独立的内核数据结构，如进程控制块（PCB）。进程切换需要更新这些数据结构。
   - 线程共享所属进程的内核数据结构，线程切换仅涉及线程自己的数据结构（如线程控制块）。

# goroutine相比线程减少的开销

Go语言中的协程（goroutine）相比于传统线程减少的开销主要体现在以下几个方面：

1. **更小的堆栈大小**：
   - 线程通常有一个相对较大的初始堆栈大小（例如，1MB）。
   - Go协程开始时的堆栈大小非常小（几KB），并且可以根据需要动态增长和缩小。这使得在相同的内存空间中可以运行更多的协程。
2. **调度开销**：
   - 线程是由操作系统内核进行调度的，这可能涉及复杂的上下文切换和调度决策。
   - Go协程由Go运行时（runtime）调度，这是一种用户级的轻量级调度，不涉及到内核级的上下文切换，因此开销更小。
3. **创建和销毁的效率**：
   - 创建和销毁线程相对较慢，因为这需要操作系统内核的直接参与。
   - Go协程的创建和销毁非常快速，因为这些操作完全在用户空间完成，无需操作系统内核的干预。
4. **内存开销**：
   - 线程的内存开销主要来自较大的堆栈和线程的内核数据结构。
   - Go协程的内存开销主要是其堆栈，由于堆栈大小动态调整，因此更加高效。
5. **并发编程模型**：
   - 线程模型通常需要开发者处理同步和互斥，这可能会引入复杂性和潜在的错误。
   - Go协程和通道（channel）提供了一种更简单的并发模型，有助于减少死锁和竞争条件等问题。

# TCB

Thread Control Block，线程控制块。

# ULT

User-Level Thread，用户级线程。

可以理解成伪线程，从操作系统视角，只能看到一个进程，时间片还是按照进程分配的，因此无法并行。

# KLT

Kernel-Level Thread，内核级线程。

# 多线程模型

常见的多线程模型

1. **一对一模型**：
   - 每个线程映射到一个内核线程。这种模型提供了最好的并行性，但线程的创建和管理开销较高。
   - 例子：Linux、Windows。
2. **多对一模型**：
   - 多个用户级线程映射到一个内核线程。这种模型中，线程管理在用户空间进行，开销较小，但一个线程的阻塞会阻塞整个进程。
   - 例子：早期的Green Threads实现。
3. **多对多模型**：
   - 多个用户级线程映射到多个内核线程。这种模型结合了一对一和多对一模型的优点，实现了良好的并行性和效率。
   - 例子：Solaris的轻量级进程（LWP）。

# 高级调度

又叫作业调度，从辅存中挑选一个作业调入内存执行。

# 低级调度

又叫进程调度，决定内存内哪个就绪进程上CPU执行。

简单理解为时间片分配给谁。

# 中级调度

又叫内存调度，是指当内存不够的时候，将某些不重要的进程暂时调到辅存上，进程进入挂起状态。 

# 临界区

操作系统中的临界区（Critical Section）是指一个多线程或多进程环境中，访问共享资源（如共享内存、共享文件等）的那部分程序代码。在任何给定时间内，只有一个线程或进程应该被允许进入临界区执行，以防止数据不一致或竞态条件。

临界区的理解：

1. **临界区是代码段**：
   - 临界区指的是程序中的一段代码，这段代码访问了共享资源（如共享内存、共享文件等）。
2. **执行临界区的代码**：
   - 当我们说一个线程或进程“进入临界区”，实际上是指它开始执行这段代码。这意味着该线程或进程在操作共享资源。
3. **互斥执行**：
   - 为了防止数据冲突或竞态条件，需要确保任何时刻只有一个线程或进程在执行临界区的代码。

# 抢占式调度

抢占式调度是一种调度机制，允许操作系统中断当前正在执行的进程，以便将CPU资源分配给其他进程。这种中断通常是基于某些策略，如时间片用尽、出现高优先级的进程等。

进程调度的方式可以按照操作系统是否能中断当前进程分为抢占式调度和非抢占式调度，对于非抢占式调度，操作系统不会主动中断进程的执行，除非进程自己中断。

# 闲逛进程 

也叫空转进程。

# CPU利用率

**CPU利用率** = （CPU忙碌时间 / 总时间）× 100%

# 系统吞吐量

单位时间内系统完成的任务数、处理的数据量或完成的操作次数。

应用场景：

- **服务器和数据中心**：评估服务器处理请求的能力。

- **网络系统**：衡量网络传输数据的速率。

- **数据库系统**：测量数据库每秒能处理的事务或查询数量。

# 周转时间

作业完成时长。

周转时间通常包括以下几个部分：

1. **等待时间**：作业在就绪队列中等待被调度的时间。
2. **服务时间**：作业在CPU上执行的实际时间。
3. **I/O时间**：作业执行过程中进行输入/输出操作所花费的时间。
4. **其他系统时间**：如作业在进行其他系统操作（如内存访问）所花费的时间。

# 调度算法

常见的调度算法：

1. **先来先服务（FCFS, First-Come, First-Served）**：
   - 最简单的调度算法，按照进程到达的顺序进行调度。
   - 优点是实现简单；缺点是平均等待时间可能较长。
2. **短作业优先（SJF, Shortest Job First）**：
   - 优先调度预计运行时间最短的进程。
   - 可以是非抢占式的，也可以是抢占式的（称为最短剩余时间优先，SRTF）。
   - 缺点是难以准确知道进程的运行时间，且可能导致长作业饥饿。
3. **轮转调度（RR, Round Robin）**：
   - 每个进程被分配一个时间片，用完时间片后如果未完成就排到队列末尾。
   - 适用于时间共享系统，提供响应性良好的交互环境。
   - 时间片的大小会影响系统性能。
4. **优先级调度**：
   - 根据进程的优先级来调度，优先级高的先执行。
   - 可以是非抢占式的或抢占式的。
   - 缺点是低优先级进程可能饥饿。
5. **多级队列调度**：
   - 将进程分配到不同的队列中，每个队列有自己的调度算法。
   - 通常每个队列代表不同的优先级。
6. **多级反馈队列**：
   - 动态地调整进程的优先级。
   - 包含多个队列，优先级不同，时间片大小不同。
   - 试图平衡作业周转时间和响应时间。
7. **实时调度**：
   - 用于实时系统，确保关键任务及时完成。
   - 包括硬实时调度和软实时调度。

# Linux的调度算法

到目前为止，Linux主要使用了以下几种调度算法：

1. **O(1)调度器**：
   - 早期的Linux 2.4和部分2.6版本使用的调度器。
   - 提供了常数时间的调度决策（即与进程数量无关），但在处理交互式进程方面表现不佳。
2. **完全公平调度器（CFS, Completely Fair Scheduler）**：
   - 从Linux 2.6.23版本开始引入。
   - 基于红黑树实现，旨在提供更好的交互性能和整体性能，尤其是在多核处理器上。
   - CFS使用虚拟运行时间来表示进程的公平性，尽量让每个进程获得相等的CPU时间。
3. **实时调度器（RT Scheduler）**：
   - Linux还包含实时调度器，用于特定的实时应用。
   - 提供了FIFO（先进先出）和RR（轮转）两种实时调度策略。
4. **Deadline调度器**：
   - 在更近期的Linux版本中引入。
   - 用于确保任务在特定的截止时间前完成。
   - 适用于对时间敏感的任务。

# 分时操作系统

- **定义**：分时操作系统是一种允许多个用户通过终端同时访问和使用计算机资源的操作系统。它通过时间片轮转的方式，将处理器时间分配给多个用户，使每个用户感觉就像他们独占了计算机。
- 特点：
  - **多任务处理**：可以同时处理多个任务。
  - **交互性**：用户可以与系统实时交互。
  - **资源共享**：系统资源（如CPU时间、内存等）被多个用户共享。
  - **时间片**：操作系统为每个任务分配一小段时间（称为时间片），然后转移到下一个任务。
- **应用场景**：通常用于教育、商业和一般计算环境，例如大学的计算机实验室、企业服务器等。

# 实时操作系统

- **定义**：实时操作系统是一种用于控制机器、科学仪器或工业系统的操作系统，它能夠在指定或确定的时间内准确完成特定的任务。
- 特点：
  - **及时响应**：能够快速且一致地响应外部事件。
  - **确定性**：任务执行时间是可以预测的。
  - **稳定性和可靠性**：在严格的时间限制下稳定运行。
  - **优先级调度**：高优先级任务会得到优先处理。
- **应用场景**：通常用于需要精确时间控制的应用，如嵌入式系统、工业控制系统、航空航天和军事设备等。

# 单标志法

# 双标志法

# 后双标志法

# peterson算法

# TS指令

Test-and-Set指令，

# SWAP指令

用于原子地交换寄存器和内存位置的值。

# CAS指令

Compare-and-Swap指令，这个指令原子地比较内存位置的值与给定值，如果相同，则用新值更新内存位置。

类似于CAS指令，TS指令在设计的时候就被特殊设计为原子操作。

这些低级的机器指令都是CPU指令集中的指令，当然不同CPU架构的指令集也有所不同，可以使用以上这些低级的机器指令来实现信号量机制和锁机制。

# PV操作

PV操作是信号量机制中的两个基本操作。

P操作原语荷兰语Proberen，意思是测试。P操作对信号量做-1操作，如果此后信号量小于0，则说明没有资源可操作，则该进程阻塞。

V操作的名称来自荷兰语单词 "Verhogen"，意味着“增加”。V操作对信号量做+1操作，因为信号量被+1了，所以P操作的进程可能会被唤醒。

# 信号量机制

信号量实现互斥的基本步骤：

1. **初始化**：信号量被初始化为1，表示共享资源可用。
2. **等待（P操作或Wait）**：
   - 当一个进程或线程想要访问共享资源时，它首先执行P操作（也称为Wait、Proberen或Pend）。
   - 在P操作中，信号量的值减1。
   - 如果信号量的值在减1后不小于0（即信号量的值在操作前是1），则进程可以继续执行，访问共享资源。
   - 如果信号量的值在减1后变成了负数（即信号量的值在操作前是0），则进程被阻塞，不允许访问资源，直到信号量的值再次变为非负数。
3. **释放（V操作或Signal）**：
   - 当进程完成对共享资源的访问后，它执行V操作（也称为Signal、Verhogen或Post）以释放锁。
   - 在V操作中，信号量的值加1。
   - 如果有其他进程因等待这个信号量而被阻塞，增加信号量的值可能会导致其中一个被阻塞的进程解除阻塞，允许它访问共享资源。

信号量实现同步操作也是相同的原理。

> 一个关键点：
>
> 当某个进程阻塞后，他并不是再次通过判断信号量来进入临界区的，而是被离开临界区的进程直接唤醒来进入临界区的。

# 管程

管程其实就是把共享数据结构和信号量机制封装成了一个模块或者对象，可供开发者直接调用，而不必关注实现互斥访问同步访问的细节。

# 动态运行时装入

早期还存在绝对装入（无操作系统时期），可重定位装入（多道批处理阶段）。

现代操作系统使用动态运行时装入，在运行时才进行地址转换。

# 静态链接

# 装入时动态链接

# 运行时动态链接

# MMU

内存管理单元。

# 上限寄存器

- **作用**：存储分配给特定程序或进程的内存段的结束物理地址。
- **内存保护**：确保程序不会访问到分配给它的内存段以上的地址空间。操作系统会阻止任何尝试访问超过上限寄存器值的内存地址的操作。

# 下限寄存器

- **作用**：存储分配给特定程序或进程的内存段的起始物理地址。
- **内存保护**：确保程序不会访问到分配给它的内存段以下的地址空间。任何尝试访问低于下限寄存器值的内存地址的操作都会被操作系统视为非法，从而防止了程序间的内存冲突和潜在的安全问题。

# 重定位寄存器基址寄存器

Base Register，又叫Relocation Register，**重定位寄存器**。

用于将逻辑地址转成物理地址。

在多道程序环境中，重定位寄存器使得每个程序都认为自己在内存的开始位置运行，从而简化了程序编写。系统通过调整重定位寄存器的值来控制程序对物理内存的访问。

例如：
假设一个程序在运行时尝试访问逻辑地址100。如果重定位寄存器的值是3000，则实际访问的物理地址将是3100（3000 + 100）。这种机制允许操作系统将同一个程序的不同实例加载到内存的不同部分，而无需修改程序本身。

# 界地址寄存器

进程最大逻辑地址。

# 覆盖技术

早期的内存管理技术。 

就是同调用层次中的最大内存空间。

但是需要程序员显式声明。

# 交换技术

 涉及到内存调度（中级调度）。

当内存紧张时，将某些进程调出内存，同时把PCB放入挂起队列保存。

进程调出内存的时候会放到外村的一个特定空间，这个就是大名鼎鼎的交换空间（终于tmd知道交换空间是干嘛用的了）。

交换空间的大小推荐为物理内存的1.5到2倍。

交换到外村的进程状态称为**挂起态**。七状态模型的由来。

# 动态分区分配

动态分区分配是一种内存管理策略，用于动态内存分配。在这种策略中，操作系统根据程序在运行时的请求，动态地分配和回收内存空间。动态分区分配主要用于管理操作系统的主存储器，目的是在需要时为程序分配足够的连续内存空间。

动态分区分配算法主要包括以下几种：

1. **首次适应算法（First Fit）**:
   - 在内存中顺序查找，直到找到第一个足够大的空闲分区来满足请求。
   - 优点是实现简单，对小的请求响应更快。
   - 缺点是可能导致内存中出现许多小的无用碎片。
2. **最佳适应算法（Best Fit）**:
   - 搜索整个内存，找到能够满足请求且最接近请求大小的空闲分区。
   - 优点是减少了空间的浪费。
   - 缺点是搜索过程较慢，且可能产生非常小的碎片。
3. **最差适应算法（Worst Fit）**:
   - 选择最大的空闲分区来满足请求。
   - 优点是减少碎片产生的频率。
   - 缺点是大的空闲分区很快会被分割成较小的部分，可能导致无法满足大的内存请求。
4. **邻近适应算法（Next Fit）**:
   - 类似于首次适应算法，但是它从上一次内存分配的地方开始查找，而不是每次都从头开始。
   - 优点是分配速度较快。
   - 缺点是可能导致内存的高地址部分变得很忙，低地址部分则相对空闲。

# 分页存储

进程被分为一个一个页(page)，而物理内存被分为一个个页框(page frame)，进程的PCB保存了一个分页表 page table，存储了这两者的映射关系。

页面的大小通常由硬件决定，常见的大小有4KB、8KB等。

页框的大小等于页面大小。

分页表维护的是虚拟页号（Virtual Page Number, VPN）和物理页框号（Physical Frame Number, PFN）之间的映射。在理解这一点时，有几个关键概念需要区分清楚：

1. **虚拟地址**：这是程序使用的地址。每个虚拟地址可以分为两部分：虚拟页号（VPN）和页内偏移（Offset）。
2. **物理地址**：这是实际的内存地址。物理地址同样可以分为两部分：物理页框号（PFN）和页内偏移（Offset）。
3. **页表**：页表中的每一项将一个虚拟页号映射到一个物理页框号。页表不直接存储完整的虚拟地址或物理地址。

当程序尝试访问一个虚拟地址时，操作系统和内存管理单元（MMU）的工作流程大致如下：

1. **分解虚拟地址**：将虚拟地址分解为虚拟页号（VPN）和页内偏移。
2. **查找页表**：使用虚拟页号在页表中查找，找到对应的物理页框号。
3. **构造物理地址**：将找到的物理页框号和原始虚拟地址中的页内偏移组合，形成完整的物理地址。
4. **访问物理内存**：使用构造出的物理地址访问实际的物理内存。

因此，页表的核心作用是将虚拟页号映射到物理页框号，而不是映射完整的虚拟地址到物理地址。页内偏移在虚拟地址和物理地址中是保持不变的，用于指定在页内的具体位置。这种设计允许操作系统有效地管理内存，同时为程序提供连续的虚拟地址空间。



























































