# 总线

双总线结构：

# CPU

CPU（中央处理单元）是计算机的大脑，负责解释和执行大部分计算机指令。它的组成结构包含多个关键部分，每个部分都有其独特的功能，共同协作以完成复杂的计算任务。以下是CPU的一些常见组成部分：

**寄存器文件**（Register File）

- 包含了一系列的寄存器，用于存储指令、数据和地址等。这些寄存器提供了CPU执行指令过程中的临时存储。

**算术逻辑单元**（ALU, Arithmetic Logic Unit）

- 负责执行所有的算术和逻辑运算，比如加法、减法、逻辑与（AND）、逻辑或（OR）等。

**控制单元**（Control Unit, CU）

- 解释指令码并控制其他部件以执行指令。它从内存中获取指令，解码、执行并将结果写回内存。

**缓存**（Cache）

- 高速缓存存储，分为L1、L2、有时还有L3。L1缓存（一级缓存）分为数据缓存（用于存储数据）和指令缓存（用于存储指令），位于CPU内部，是CPU直接访问的最快的存储区域之一。

**流水线**（Pipeline）

- 使CPU能够同时执行多个指令的技术。通过将指令的执行过程分解为多个阶段，不同阶段的指令可以并行处理，提高执行效率。

**浮点单元**（Floating Point Unit, FPU）

- 专门用于处理浮点数计算的部件。在一些处理器中，它也被称为数学协处理器。

**总线接口单元**（Bus Interface Unit, BIU）

- 负责与外部总线和其他部件的数据通信，包括内存、I/O设备等的数据交换。

**指令预取单元**（Instruction Fetch Unit）

- 用于从内存或缓存中预取指令到CPU内部，准备进行解码和执行。

**分支预测器**（Branch Predictor）

- 预测程序中分支（如if-else语句）的走向，以减少分支造成的延迟，提高流水线的效率。

**微指令集**（Microcode）

- 一种在更高级别的指令集和硬件之间提供额外抽象层的机制。微指令集用于控制CPU的低级操作。

CPU的设计高度复杂，旨在高效执行各种计算任务。从寄存器到高速缓存，再到控制单元和算术逻辑单元，每个组成部分都为处理器的性能做出贡献。了解这些基本组成部分有助于理解CPU如何处理指令，以及为什么现代处理器能够以惊人的速度执行复杂的程序。



# 寄存器 

在现代CPU中，有多种寄存器，每种寄存器都有其特定的用途。以下是一些最常见的寄存器类型：

**程序计数器**（Program Counter, PC）

- 存储下一条指令的内存地址（逻辑地址），指导CPU从哪里获取下一条要执行的指令。

**指令寄存器**（Instruction Register, IR）

- 存储当前正在被CPU执行的指令。

**累加器**（Accumulator）

- 用于临时存储算术和逻辑操作的结果，简化数据处理过程。

**栈指针**（Stack Pointer, SP）

- 指向当前的栈顶地址，管理函数调用和返回时的参数和局部变量存储。

**帧指针**（Frame Pointer, FP）或基指针（Base Pointer, BP）

- 用于指向函数栈帧的开始，辅助访问函数参数和局部变量。

**状态寄存器**/标志寄存器（Status Register / Flag Register）

- 存储CPU执行指令后的状态信息，如零标志、进位标志、溢出标志等。

**通用寄存器**（General Purpose Registers）

- 提供临时存储和操作数据的能力，可以被程序用于多种目的。

**浮点寄存器**（Floating Point Registers）

- 专门用于存储浮点数和执行浮点运算的结果。

**内存地址寄存器**（Memory Address Register, MAR）

- 存储要从内存读取或写入数据的地址。

**内存数据寄存器**（Memory Data Register, MDR）或内存缓冲寄存器（Memory Buffer Register, MBR）

- 用于临时存储从内存读取的数据或准备写入内存的数据。

**控制寄存器**（Control Registers）

- 包含控制处理器操作的关键信息，如虚拟内存配置、缓存控制等。

这些寄存器在CPU的设计和运作中起着核心作用，它们使得CPU能够执行程序、管理内存访问、处理数据以及控制执行流程。每种类型的寄存器都有其特定的用途，确保了处理器能够高效、准确地完成其任务。



# MAR

Memory Address Register，存储地址寄存器，用于存储目标内存地址。

在64位系统中，MAR通常是64位的，理论上可以寻址高达$2^{64}$个地址。

# MDR

存储数据寄存器，也叫MBR(Memory Buffer Register)，用于暂存数据。

通常情况下，MDR的位数与CPU的字长（word size）一致，但这并不是一个严格的规则。字长指的是CPU一次操作能够处理的标准数据大小。

# Cache

高速缓冲存储器，现代计算机系统通常采用多级缓存架构，如L1、L2和L3缓存。L1缓存最快但容量最小，通常内置于CPU芯片内；L2和L3缓存较大，速度略慢，可能位于CPU芯片上或芯片附近。

类型也可以分为数据缓存和指令缓存。

用户程序通常无法直接控制硬件缓存，但它可以通过设计选择来影响缓存的有效性，例如：

- **优化数据局部性**：通过改善数据访问模式来优化缓存命中率。
- **使用非缓存内存映射**：在某些系统上，程序可能能请求映射一块非缓存的物理内存区域，特别是在与硬件设备交互时。

> 优化数据局部性（Data Locality）是计算机程序设计中的一种重要技术，旨在提高缓存命中率，从而提升程序的性能。数据局部性主要分为两类：时间局部性（Temporal Locality）和空间局部性（Spatial Locality）。
>
> ### 时间局部性（Temporal Locality）
>
> 时间局部性指的是被访问的数据项在近期将很可能再次被访问。为了优化时间局部性，可以采取以下措施：
>
> 1. **重用数据**：
>    - 尽量重用变量和数据结构。例如，在循环中重用相同的变量而不是每次都创建新变量。
> 2. **保持对象活跃**：
>    - 将经常使用的对象保持在内存中，而不是频繁地创建和销毁它们。
>
> ### 空间局部性（Spatial Locality）
>
> 空间局部性指的是如果程序访问了某个数据项，那么其附近的数据项不久后也很可能被访问。为了优化空间局部性，可以采取以下措施：
>
> 1. **顺序访问**：
>    - 尽量顺序地访问数组和数据结构，这样缓存能够有效地预加载接下来的数据。
> 2. **数据结构选择**：
>    - 选择合适的数据结构以提高空间局部性。例如，数组通常比链表具有更好的空间局部性。
> 3. **数据布局**：
>    - 在内存中紧凑地布局相关数据，减少数据散布。
>
> ### 编程技巧
>
> - 循环变换：
>   - 如循环展开（Loop Unrolling）以减少循环开销和提高缓存利用率。
> - 分块处理：
>   - 将数据划分为小块（如矩阵乘法中的分块），使得每个小块能够有效地加载到缓存中处理。

循环展开的思想类似于：

展开前：

```c
#include <stdio.h>

int main()
{
        int count = 0;
        int n = 20; 
        for (int i = 0; i< n; i++) {
                count++;
                printf("%d\n", count);
        }
}
```

展开后：

```c
#include <stdio.h>

int main()
{
        int count = 0;
        int n = 20; 
        for (int i = 0; i< n; i+=2) {
                count++;
                printf("%d\n", count);
                count++;
                printf("%d\n", count);
        }
}
```

但是现代编译器通常能够自动进行循环展开等优化。在手动进行循环展开之前，最好先检查编译器的优化设置。

# SSD

固态硬盘。

通过闪存技术存储数据，物理载体是半导体，没有移动部件。

# HDD

机械硬盘。

物理载体是磁性物质，通过正负极表示0，1，写入操作时需要频繁移动磁头，效率低。