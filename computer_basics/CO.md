# MAR

Memory Address Register，存储地址寄存器，用于存储目标内存地址。

在64位系统中，MAR通常是64位的，理论上可以寻址高达$2^{64}$个地址。

# MDR

存储数据寄存器，也叫MBR(Memory Buffer Register)，用于暂存数据。

通常情况下，MDR的位数与CPU的字长（word size）一致，但这并不是一个严格的规则。字长指的是CPU一次操作能够处理的标准数据大小。

# 寄存器



# Cache

高速缓冲存储器，现代计算机系统通常采用多级缓存架构，如L1、L2和L3缓存。L1缓存最快但容量最小，通常内置于CPU芯片内；L2和L3缓存较大，速度略慢，可能位于CPU芯片上或芯片附近。

类型也可以分为数据缓存和指令缓存。

用户程序通常无法直接控制硬件缓存，但它可以通过设计选择来影响缓存的有效性，例如：

- **优化数据局部性**：通过改善数据访问模式来优化缓存命中率。
- **使用非缓存内存映射**：在某些系统上，程序可能能请求映射一块非缓存的物理内存区域，特别是在与硬件设备交互时。

> 优化数据局部性（Data Locality）是计算机程序设计中的一种重要技术，旨在提高缓存命中率，从而提升程序的性能。数据局部性主要分为两类：时间局部性（Temporal Locality）和空间局部性（Spatial Locality）。
>
> ### 时间局部性（Temporal Locality）
>
> 时间局部性指的是被访问的数据项在近期将很可能再次被访问。为了优化时间局部性，可以采取以下措施：
>
> 1. **重用数据**：
>    - 尽量重用变量和数据结构。例如，在循环中重用相同的变量而不是每次都创建新变量。
> 2. **保持对象活跃**：
>    - 将经常使用的对象保持在内存中，而不是频繁地创建和销毁它们。
>
> ### 空间局部性（Spatial Locality）
>
> 空间局部性指的是如果程序访问了某个数据项，那么其附近的数据项不久后也很可能被访问。为了优化空间局部性，可以采取以下措施：
>
> 1. **顺序访问**：
>    - 尽量顺序地访问数组和数据结构，这样缓存能够有效地预加载接下来的数据。
> 2. **数据结构选择**：
>    - 选择合适的数据结构以提高空间局部性。例如，数组通常比链表具有更好的空间局部性。
> 3. **数据布局**：
>    - 在内存中紧凑地布局相关数据，减少数据散布。
>
> ### 编程技巧
>
> - 循环变换：
>   - 如循环展开（Loop Unrolling）以减少循环开销和提高缓存利用率。
> - 分块处理：
>   - 将数据划分为小块（如矩阵乘法中的分块），使得每个小块能够有效地加载到缓存中处理。

循环展开的思想类似于：

展开前：

```c
#include <stdio.h>

int main()
{
        int count = 0;
        int n = 20; 
        for (int i = 0; i< n; i++) {
                count++;
                printf("%d\n", count);
        }
}
```

展开后：

```c
#include <stdio.h>

int main()
{
        int count = 0;
        int n = 20; 
        for (int i = 0; i< n; i+=2) {
                count++;
                printf("%d\n", count);
                count++;
                printf("%d\n", count);
        }
}
```

但是现代编译器通常能够自动进行循环展开等优化。在手动进行循环展开之前，最好先检查编译器的优化设置。

# SSD

固态硬盘。

通过闪存技术存储数据，物理载体是半导体，没有移动部件。

# HDD

机械硬盘。

物理载体是磁性物质，通过正负极表示0，1，写入操作时需要频繁移动磁头，效率低。